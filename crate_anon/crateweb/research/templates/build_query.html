{# build_query.html #}

{% extends "base.html" %}
{% load staticfiles %}

{% block collapsejs %}{% endblock %}
{% block extrahead %}
    <script type="text/javascript" src="{% static 'querybuilder.js' %}"></script>
    <script type="text/javascript">
var DATABASE_STRUCTURE = {{ database_structure|safe }},
    STARTING_VALUES = {{ starting_values|safe }};
    </script>
{% endblock %}
{% block onload %}onload="populate()"{% endblock %}

{% block content %}

    {% include "query_nav.html" %}

    <h1>Build a simple query</h1>
    <p>For more advanced queries, see the
        <a href="{% url 'query' %}">SQL view</a>.</p>

    <h2>Current query</h2>
    {% if parse_error %}
        <div class="warning">SQL FAILED TO PARSE. Please clear the query.
            Error was: {{ parse_error }}</div>
    {% endif %}
    {% if sql %}
        <pre class="sql">{{ sql }}</pre>
        <form action="{% url 'build_query' %}" method="post">
            {% csrf_token %}
            <input type="submit" name="global_clear" value="Clear" />
            {% if not parse_error %}
                <input type="submit" name="global_toggle_distinct"
                       value="Toggle DISTINCT" />
                <input type="submit" name="global_save" value="Save as query" />
                <input type="submit" name="global_run" value="Run" />
            {% endif %}
        </form>
    {% else %}
        {# single space to show the area visually #}
        <pre class="sql"> </pre>
    {% endif %}

    <h2>Build your query!</h2>
    <div>
        <span id="id_current_column" class="titlecolour">Please choose a table and column:</span>
        <span id="id_comment"></span>
    </div>
    <div id="id_coltype_info"></div>
    <div id="id_warning" class="warning"></div>
    <form action="{% url 'build_query' %}" method="post" enctype="multipart/form-data">
        {% csrf_token %}
        <!-- name tags must match QueryBuilderForm -->
        <select id="id_schema" name="schema" title="Database schema"></select>
        <select id="id_table" name="table" title="Database table"></select>
        <select id="id_column" name="column" title="Column (field) within table"></select>
        <input id="id_coltype" type="hidden" name="datatype" title="" value="">
        <input id="id_offer_where" type="hidden" name="offer_where" title="" value="">
        <select id="id_where_op" name="where_op" title="WHERE operation"></select>
        <input id="id_where_value_date" type="date" name="date_value" title="Value (date)" value="">
        <input id="id_where_value_float" type="number" name="float_value" title="Value (floating-point number)" step="any" value="">
        <input id="id_where_value_integer" type="number" name="int_value" title="Value (integer)" step="1" value="">
        <input id="id_where_value_text" type="text" name="string_value" title="Value (string)" value="">
        <input id="id_file" type="file" name="file">
        <br>
        <input id="id_where_button" type="submit" name="submit_where" value="Set condition (WHERE)">
        <br>
        <br>
        <input type="submit" name="submit_select" value="Add to output (SELECT)">
    </form>

    <h2>Tips</h2>
    <ul>
        <li>Inexact string comparison can be done in several ways:
            <ul>
                <li><a href="http://dev.mysql.com/doc/refman/5.7/en/pattern-matching.html">LIKE</a>,
                    in which ‘%’ stands for any number of characters, and ‘_’
                    for one unknown character. For example, use
                    <span class="code">%schizophreni%</span> to find text
                    containing ‘schizophrenia’, ‘schizophrenic’, or
                    ‘schizophreniform’.</li>
                <li><a href="https://dev.mysql.com/doc/refman/5.7/en/fulltext-search.html">MATCH</a>,
                    which is much faster than LIKE. MATCH can be used if there
                    is a full-text index on the column in question. You can
                    MATCH AGAINST words or phrases.</li>
                <li><a href="http://dev.mysql.com/doc/refman/5.7/en/pattern-matching.html">REGEXP</a>,
                    using <a href="https://en.wikipedia.org/wiki/Regular_expression">regular expressions</a>.
                    This is complicated; see a <a href="http://regexone.com/">tutorial</a>
                    and use a <a href="http://regexr.com/">regular expression tester</a>.</li>
            </ul></li>

        <li>This query builder parses the SQL you start with, and then
            adds more pieces. It is less powerful than arbitrary SQL.</li>

        <li>
            Things that are are better done with raw SQL include:
            <ul>
                <li>Combining expressions with OR, or in complex ways.</li>
                <li>Restricting to a set of values with IN.</li>
                <li>Finding information about patients P that “have” something
                    (e.g. a diagnosis) using EXISTS.</li>
            </ul>
        </li>

        <li>If you use a file (for IN or NOT IN clauses), this file should be
            in ASCII or UTF-8 format, with one value per line. Lines will
            be stripped of whitespace (left + right). Lines starting with
            a # character will be treated as comments and ignored.</li>

    </ul>

    <h2>Explanation</h2>
    <ul>
        <li>This query builder <b>only looks at tables that contain patient
            information</b> (as judged by the presence of the “transient
            research ID” (TRID) field, defined by your database manager).
            It ignores “system” tables with no connection to a patient.
            If you want to explore all the tables, explore the database
            structure using the options on the
            <a href="{% url 'home' %}">Main menu</a>, and use the
            <a href="{% url 'query' %}">SQL view</a> to create a more complex
            query.</li>

        <li>The query builder will automatically JOIN tables based on a shared
            TRID (i.e. records for the same patient). The TRID is a numerical
            value that identifies a patient. It’s quicker for queries than the
            “master research ID” (RID), but the RID will stay constant if/when
            the research database is rebuilt, and the TRID might change, so
            you should make a note of the RID if you want to save data.
            The RID is typically an encrypted patient identifier from the source
            database; the TRID is taken from a one-time pad.</li>

        <li>More complex automatic joins across databases are
            <b>not yet implemented.</b></li>

    </ul>

{% endblock %}
